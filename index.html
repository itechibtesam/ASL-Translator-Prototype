<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ASL Translator Prototype - Final Production Code</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* 1. Global & Background */
        body {
            margin: 0;
            overflow: hidden;
            background: #000000;
            font-family: 'Poppins', sans-serif;
            color: #E0E0E0;
            width: 100vw; 
            height: 100vh;
        }
        video { display: none; }
        
        /* Ensures the canvas takes up the full screen */
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* 2. GUI Panel (Centralized Frosted Glass) */
        #gui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; 
            max-width: 400px; 
            z-index: 100;
            padding: 30px;
            border-radius: 20px; 
            background: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px);
            pointer-events: none; 
        }
        
        /* Ensure all interactive elements inside GUI are tappable */
        #voice-selector-container, #voice-select {
            pointer-events: auto; 
        }

        h3 {
            font-size: 1.6em; 
            font-weight: 700; 
            color: #4CAF50;
            margin-top: 0;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
        }

        /* Instruction List Styling */
        .instructions-heading {
            font-weight: 600;
            margin-bottom: 5px;
            color: #A9A9A9;
        }

        ul {
            list-style: disc; 
            padding-left: 20px;
            margin-bottom: 30px;
            font-weight: 300;
            line-height: 1.6;
        }
        
        ul li {
            margin-bottom: 8px;
        }
        
        /* 3. Status Indicators */
        .status-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .status { 
            color: #FFC107; 
            font-weight: 600;
        }
        
        .recognized { 
            color: #4CAF50; 
            font-weight: 600;
        }
        
        .unclear { 
            color: #FF5252;
            font-weight: 600;
        }

        /* 4. Primary Output Text */
        #output-text {
            font-size: 1.8em; 
            font-weight: 700;
            color: #00FFFF;
            text-align: center;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            min-height: 1.2em;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.5); 
        }

        /* 5. Voice Selector Styling */
        #voice-selector-container {
            margin-bottom: 20px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #voice-select {
            width: 100%;
            padding: 10px;
            font-family: 'Poppins', sans-serif;
            font-size: 1em;
            font-weight: 500;
            color: #E0E0E0;
            background: rgba(255, 255, 255, 0.15); 
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            appearance: none; 
        }
        #voice-select option {
            background: #0d1117; 
            color: #E0E0E0;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="gui">
        <h3>Sign to Speech Translator</h3>

        <div id="voice-selector-container">
            <label for="voice-select" style="font-size: 0.9em; font-weight: 300;">Select Voice:</label>
            <select id="voice-select">
                <option value="default" disabled>Loading Voices...</option>
            </select>
        </div>

        <div class="instructions-heading">Operation Instructions:</div>
        <ul>
            <li>Open Hand: System starts the listening process.</li>
            <li>**Hold Sign for 1 Second:** Automatically confirms the sign and speaks the translation.</li>
            <li>No additional pinch/close gesture is required.</li>
        </ul>

        <div class="status-line">
            System State: <span id="system-status" class="status">Loading Camera...</span>
        </div>
        
        <div class="status-line">
            Current Sign: <span id="current-sign" class="unclear">Waiting...</span>
        </div>

        <div id="output-text"></div>
    </div>
    
    <video id="input_video"></video>

    <script>
        // --- CONFIGURATION & CONSTANTS ---
        const PARTICLE_COUNT = 5000;
        const CAM_WIDTH = 640;
        const CAM_HEIGHT = 480;
        const STABILITY_HOLD_TIME = 800; 
        const SPEAK_CONFIRM_TIME = 1000; 

        // Landmark indices for geometry checks
        const L_THUMB_TIP = 4;
        const L_INDEX_TIP = 8;
        const L_MIDDLE_TIP = 12;
        const L_RING_TIP = 16;
        const L_PINKY_TIP = 20;

        // --- GLOBAL STATE ---
        let handLandmarks = null;
        let isHandPresent = false;
        let recognizedSign = 'Unclear';
        let lastStableSign = 'Unclear';
        let confidenceLevel = 0.0;
        let stabilityTimer = null;
        let speakTimer = null; 
        let isSpeaking = false;
        let currentShapeTarget = 'sphere'; 
        
        // --- VOICE STATE ---
        let selectedVoiceName = null; // Store the selected string name
        let availableVoices = [];
        let maleVoiceActual = null; // The actual Voice object for the male role
        let femaleVoiceActual = null; // The actual Voice object for the female role
        let voiceRetryInterval = null; 


        // --- DOM Elements ---
        const statusEl = document.getElementById('system-status');
        const signEl = document.getElementById('current-sign');
        const outputEl = document.getElementById('output-text');
        const voiceSelect = document.getElementById('voice-select');


        // --- VOICE SETUP (FINAL ROBUST VERSION) ---
        const synth = window.speechSynthesis;
        let lastSpokenText = '';

        /**
         * Finds distinct voices by trying to match common gender keywords.
         */
        function findVoices(voices) {
            const enVoices = voices.filter(v => v.lang.startsWith('en'));
            
            let maleV = enVoices.find(v => v.name.toLowerCase().includes('male') || v.name.toLowerCase().includes('david') || v.name.toLowerCase().includes('daniel'));
            let femaleV = enVoices.find(v => v.name.toLowerCase().includes('female') || v.name.toLowerCase().includes('samantha') || v.name.toLowerCase().includes('zira'));

            // Fallbacks: take the first two unique English voices found
            if (!maleV && enVoices.length >= 1) {
                maleV = enVoices[0];
            }
            if (!femaleV && enVoices.length >= 2) {
                femaleV = enVoices.find(v => v.name !== maleV.name);
            }
            if (!femaleV) {
                femaleV = maleV;
            }

            return { maleV, femaleV };
        }

        /**
         * Populates the voice list using the two found English voices.
         */
        function populateVoiceList() {
            availableVoices = synth.getVoices();
            
            if (availableVoices.length > 0) {
                 if (voiceRetryInterval) {
                     clearInterval(voiceRetryInterval);
                     voiceRetryInterval = null;
                 }
            } else {
                return; 
            }

            voiceSelect.innerHTML = ''; 

            const { maleV, femaleV } = findVoices(availableVoices);

            if (!maleV) {
                 voiceSelect.innerHTML = '<option value="default" disabled>No English Voices Found</option>';
                 return;
            }

            // Store the actual Voice objects for use in speak()
            maleVoiceActual = maleV;
            femaleVoiceActual = femaleV;
            
            // --- 1. Add Male Voice Option ---
            const maleOption = document.createElement('option');
            // Use simple distinguishable string values for selection
            maleOption.value = 'Male'; 
            maleOption.textContent = `Male Voice (${maleV.name.split(' ').slice(0, 2).join(' ')})`;
            voiceSelect.appendChild(maleOption);
            selectedVoiceName = 'Male'; // Set default selection

            // --- 2. Add Female Voice Option ---
            const femaleOption = document.createElement('option');
            femaleOption.value = 'Female';
            femaleOption.textContent = `Female Voice (${femaleV.name.split(' ').slice(0, 2).join(' ')})`;
            voiceSelect.appendChild(femaleOption);
            
            voiceSelect.value = selectedVoiceName;
        }

        // --- VOICE INITIALIZATION (ROBUST RETRY) ---
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = populateVoiceList;
        } 
        
        if (synth.getVoices().length === 0) {
            voiceRetryInterval = setInterval(populateVoiceList, 500);
        }

        voiceSelect.addEventListener('change', () => {
            selectedVoiceName = voiceSelect.value;
        });

        /**
         * Speaks the text, using the actual voice object AND applying pitch/rate.
         */
        function speak(text) {
            if (synth.speaking || text === lastSpokenText || !selectedVoiceName) return;
            isSpeaking = true;
            
            const utterThis = new SpeechSynthesisUtterance(text);
            
            if (selectedVoiceName === 'Female') {
                // Apply female characteristics
                utterThis.pitch = 1.2; 
                utterThis.rate = 0.95; 
                if (femaleVoiceActual) {
                    utterThis.voice = femaleVoiceActual;
                }
            } else { // Male (default)
                // Apply male characteristics
                utterThis.pitch = 0.8; 
                utterThis.rate = 0.8;  
                if (maleVoiceActual) {
                    utterThis.voice = maleVoiceActual;
                }
            }
            
            utterThis.onend = () => {
                isSpeaking = false;
                lastSpokenText = text;
            };
            synth.speak(utterThis);
        }

        // --- GEOMETRY UTILITIES (UNCHANGED) ---

        function distance(lm1, lm2) {
            return Math.sqrt(
                Math.pow(lm1.x - lm2.x, 2) +
                Math.pow(lm1.y - lm2.y, 2) +
                Math.pow(lm1.z - lm2.z, 2)
            );
        }
        
        function isFingerExtended(landmarks, tipIndex) {
            const tip = landmarks[tipIndex];
            const mcp = landmarks[tipIndex - 3];
            return tip.y < mcp.y - 0.05;
        }

        // --- SIGN RECOGNITION LOGIC (UNCHANGED) ---

        function getSignFromLandmarks(landmarks) {
            const isThumbOpen = isFingerExtended(landmarks, L_THUMB_TIP);
            const isIndexOpen = isFingerExtended(landmarks, L_INDEX_TIP);
            const isMiddleOpen = isFingerExtended(landmarks, L_MIDDLE_TIP);
            const isRingOpen = isFingerExtended(landmarks, L_RING_TIP);
            const isPinkyOpen = isFingerExtended(landmarks, L_PINKY_TIP);
            
            // 1. Hello (Open Hand)
            if (isThumbOpen && isIndexOpen && isMiddleOpen && isRingOpen && isPinkyOpen) {
                confidenceLevel = 0.9;
                currentShapeTarget = 'sphere';
                return 'Hello';
            }

            // 2. I Love You (ILY - Index, Pinky, Thumb extended)
            if (isIndexOpen && isPinkyOpen && isThumbOpen && !isMiddleOpen && !isRingOpen) {
                confidenceLevel = 0.8;
                currentShapeTarget = 'heart';
                return 'I Love You ';
            }
            
            // 3. No / Fist (All fingers curled)
            if (!isThumbOpen && !isIndexOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                confidenceLevel = 0.7;
                currentShapeTarget = 'small_sphere';
                return 'No';
            }

            // 4. Index Finger (Request/Help - Index extended only)
            if (isIndexOpen && !isThumbOpen && !isMiddleOpen && !isRingOpen && !isPinkyOpen) {
                confidenceLevel = 0.85;
                currentShapeTarget = 'saturn';
                return 'Help / Pointing';
            }

            confidenceLevel = 0.0;
            currentShapeTarget = 'chaos';
            return 'Unclear';
        }

        // --- MEDIAPIPE HANDLER (TIME-BASED CONFIRMATION LOGIC - UNCHANGED) ---

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
                isHandPresent = true;
                
                const newSign = getSignFromLandmarks(handLandmarks);
                
                if (newSign !== 'Unclear' && newSign === lastStableSign) {
                    if (!stabilityTimer) {
                        stabilityTimer = setTimeout(() => {
                            recognizedSign = newSign;
                            signEl.innerText = recognizedSign;
                            signEl.className = 'recognized';
                            
                            if (!speakTimer && !isSpeaking) {
                                speakTimer = setTimeout(() => {
                                    outputEl.innerText = `Speaking: ${recognizedSign}...`;
                                    speak(recognizedSign);
                                    
                                    recognizedSign = 'Unclear';
                                    lastStableSign = 'Unclear';
                                    signEl.innerText = 'Spoken';
                                    speakTimer = null; 
                                }, SPEAK_CONFIRM_TIME);
                            }

                        }, STABILITY_HOLD_TIME);
                    }
                } else {
                    clearTimeout(stabilityTimer);
                    clearTimeout(speakTimer);
                    stabilityTimer = null;
                    speakTimer = null;
                    
                    lastStableSign = newSign;
                    recognizedSign = 'Unclear';

                    if (!isSpeaking) {
                        signEl.innerText = newSign;
                        signEl.className = newSign === 'Unclear' ? 'unclear' : 'status';
                    }
                }

                statusEl.innerText = 'Listening & Tracking';
                statusEl.className = 'recognized';

            } else {
                clearTimeout(stabilityTimer);
                clearTimeout(speakTimer);
                stabilityTimer = null;
                speakTimer = null;

                isHandPresent = false;
                recognizedSign = 'Unclear';
                lastStableSign = 'Unclear';
                statusEl.innerText = 'Waiting for Hand';
                statusEl.className = 'status';
                if (!isSpeaking) {
                    outputEl.innerText = '';
                }
            }
        }

        // --- MEDIAPIPE & CAMERA SETUP (UNCHANGED) ---

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ 
            maxNumHands: 1, 
            modelComplexity: 0, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        hands.onResults(onResults);

        const videoElement = document.getElementById('input_video');
        
        setTimeout(() => {
            try {
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: CAM_WIDTH, 
                    height: CAM_HEIGHT,
                    facingMode: 'user' 
                });
                cameraUtils.start();
                statusEl.innerText = 'Camera Initialized';
            } catch (error) {
                console.error("Camera startup failed:", error);
                statusEl.innerText = 'ERROR: Check Camera Permissions';
                statusEl.className = 'unclear';
            }
        }, 500); 

        // --- THREE.JS & ANIMATION (UNCHANGED) ---
        
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targets = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            targets[i*3] = positions[i*3];
            targets[i*3+1] = positions[i*3+1];
            targets[i*3+2] = positions[i*3+2];
            colors[i*3] = colors[i*3+1] = colors[i*3+2] = 0.5;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const getSprite = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        };

        const material = new THREE.PointsMaterial({
            size: 0.6,
            map: getSprite(),
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        function setTargetShape(shapeType) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let x, y, z;
                let r, theta, phi;

                if (shapeType === 'sphere') {
                    r = 15;
                    theta = Math.random() * Math.PI * 2;
                    phi = Math.acos((Math.random() * 2) - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } else if (shapeType === 'heart') {
                    r = Math.random() * 2; 
                    theta = Math.random() * Math.PI * 2;
                    const hx = 16 * Math.pow(Math.sin(theta), 3);
                    const hy = 13 * Math.cos(theta) - 5 * Math.cos(2*theta) - 2 * Math.cos(3*theta) - Math.cos(4*theta);
                    x = hx * 0.8 + (Math.random() - 0.5) * r;
                    y = hy * 0.8 + (Math.random() - 0.5) * r;
                    z = (Math.random() - 0.5) * 10;
                } else if (shapeType === 'saturn') {
                    const isRing = Math.random() > 0.6;
                    if(isRing) {
                        r = 20 + Math.random() * 10;
                        theta = Math.random() * Math.PI * 2;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random() - 0.5) * 2;
                    } else {
                        r = 10;
                        theta = Math.random() * Math.PI * 2;
                        phi = Math.acos((Math.random() * 2) - 1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                } else if (shapeType === 'chaos' || shapeType === 'small_sphere') {
                    r = shapeType === 'chaos' ? 50 : 8;
                    x = (Math.random() - 0.5) * r;
                    y = (Math.random() - 0.5) * r;
                    z = (Math.random() - 0.5) * r;
                }

                targets[idx] = x;
                targets[idx+1] = y;
                targets[idx+2] = z;
            }
        }
        setTargetShape(currentShapeTarget);

        const clock = new THREE.Clock();
        let lastShape = currentShapeTarget;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            const positionsArr = geometry.attributes.position.array;
            const colorsArr = geometry.attributes.color.array;

            if (lastShape !== currentShapeTarget) {
                setTargetShape(currentShapeTarget);
                lastShape = currentShapeTarget;
            }

            let expansionFactor = 1.0;
            let morphSpeed = 0.05;
            let targetR = 0.5, targetG = 0.5, targetB = 0.5;

            if (isSpeaking) {
                targetR = 0.5; 
                targetG = 1.0; 
                targetB = 1.0;
                expansionFactor = 2.0;
                morphSpeed = 0.2;
            } else if (isHandPresent) {
                targetR = 1.0 - confidenceLevel;
                targetG = confidenceLevel;
                targetB = 0.2 + confidenceLevel * 0.8;
                expansionFactor = 1.2; 
                morphSpeed = 0.1;
            } else {
                targetR = targetG = targetB = 0.1;
                expansionFactor = 1.0;
                morphSpeed = 0.01;
                particles.position.x = 0; 
                particles.position.y = 0;
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;

                const tx = targets[idx] * expansionFactor;
                const ty = targets[idx+1] * expansionFactor;
                const tz = targets[idx+2] * expansionFactor;

                positionsArr[idx] += (tx - positionsArr[idx]) * morphSpeed;
                positionsArr[idx+1] += (ty - positionsArr[idx+1]) * morphSpeed;
                positionsArr[idx+2] += (tz - positionsArr[idx+2]) * morphSpeed;

                colorsArr[idx] += (targetR - colorsArr[idx]) * 0.1;
                colorsArr[idx+1] += (targetG - colorsArr[idx+1]) * 0.1;
                colorsArr[idx+2] += (targetB - colorsArr[idx+2]) * 0.1;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            particles.rotation.y += delta * 0.05; 

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
